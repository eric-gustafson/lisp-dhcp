#+title: work

* TODO Today
** return objects for host info kinds of things
** remote and local should map to same basic object model

* TODO host-info
** interface-lists
** ip-address



** configure-parent-router
   #1 use case
*** TODO get wireless (name . ip) list
**** TODO configure down stream router w/ info
***** TODO
#+BEGIN_SRC lisp
  (lsa:iwconfig-interface-list)
#+END_SRC

#+RESULTS:
| wlo1 |

#+BEGIN_SRC lisp
  (lsa:ip-link)
#+END_SRC

#+RESULTS:
| lo   | <LOOPBACK,UP,LOWER_UP>            | mtu | 65536 | qdisc | noqueue | state | UNKNOWN | mode | DEFAULT | group | default | qlen | 1000 |
| wlo1 | <BROADCAST,MULTICAST,UP,LOWER_UP> | mtu |  1500 | qdisc | mq      | state | UP      | mode | DORMANT | group | default | qlen | 1000 |


#+BEGIN_SRC lisp :results value
  (lsa:ip-addr)
#+END_SRC

#+RESULTS:
| lo   |      127.0.0.1 |
| wlo1 | 192.168.11.255 |


** TODO setup two laptops downstairs

** TODO bring this up on laptop
*** TODO try using submodules 
*** TODO 2nd laptop joins g3
    traceroute, find out why we are not routing



* RBPI
** Port to ccl-bin
** Port to ecl

* TODO Laptop
** TODO turn network watchdog off and on
** TODO syslog
** TODO dhcp client
   Do we maybe want to get rid of network manager?


* TODO get routing working

#+BEGIN_SRC sh
    gksu ip a add 192.168.12.1/255.255.255.0 dev wlx9cefd5fdd60e
#+END_SRC

#+RESULTS:

* TODO network watchdog
  if after 15m, there is no network connectivity -- reboot


* TODO have everything come up from a boot
  hostapd brings the interface up.  Bringing the interface up before
  running that hostapd put things into a state that I couldn't recover
  from without a reboot. (I think I have a little scriplet here somewhere
  that would recover ...)

  The thing is, we need a fork/exec init kind of thing to run from here.
  
** TODO Have the program install everything to run as a daemon

** TODO add the interface

#+BEGIN_SRC sh
   apt-get install -y lib-ssh2-1-dev
#+END_SRC

#+RESULTS:

   Get the interface

#+BEGIN_SRC sh
   #ip link set dev wlx9cefd5fdd60e up
#+END_SRC

#+RESULTS:
#+BEGIN_SRC sh :results output 
   ip link
#+END_SRC   

#+RESULTS:
: 1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
:     link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
: 2: wlo1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP mode DORMANT group default qlen 1000
:     link/ether 48:45:20:ef:5b:e6 brd ff:ff:ff:ff:ff:ff


* TODO create a commissioning network
  This is a virtual interface with a network allocated from *network-malloc*


** TODO verfify that this shows up on RBPI

** TODO up/down this network
   (defmethod net-up ((obj netobj))
    )

   
** TODO allocate IP and network info



** TODO simple/dumb dhcp address allocation
   incf for now


* TODO Receive and decode dhcp broadcast
  To send and receive broadcast

** netmask
   Be sure that netmask is correct. in windows mask for broadcast
    packets does not matters, but not in linux.

** wildcard address
   bind socket to INADDR_ANY

** setsockopt
   setsockopt to BROADCAST

** sendto
   call sendto with sendaddr.sin_addr.s_addr = inet_addr("your_interface_broadcast_address")

   call sento several times for each interface with its broadcast ip address.

** call recvfrom. any time before calling recvfrom, set up length parameter




* TODO move netsecurity.org document for erlang dhcp project here
  It was all there, except for the actual way to stop x-talk on the wireless lan (seperate networks for each node)



* TODO Add a section to construct a reply
  Use the *commissioning-network* info above

* TODO change the print-object to display mac address
  mac address should use the 'size' operator which is one of the first parameters
  which then allows us to trim the chaddr field.

* DONE dhcp network based ip allocation code

* DONE give the same address out for mac hit

