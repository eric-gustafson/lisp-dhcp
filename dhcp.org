#+title: dhcp protocol meta code

* Goals
  - To produce key resources to handle the dhcp protocol
  - To distribute dhcp servers into the mesh
    - seperate networks for each node
    - don't allow IP connectivity to other nodes
    - profile management
    - qos


* COMMENT Setup
** Lisp
#+BEGIN_SRC lisp
   (ql:quickload :alexandria)
   (ql:quickload :trivia)
   (ql:quickload :serapeum)
   (ql:quickload :flexi-streams)
#+END_SRC

  
#+BEGIN_SRC lisp
  (defun ->symbol (str)
    (intern (string-upcase str)))

  (defun ->keyword (str)
    (intern (string-upcase str) :keyword))
#+END_SRC


** Elisp
#+BEGIN_SRC elisp
    (defun buff-basename ()
      (file-name-base (buffer-name (current-buffer)))
      )
    (defun buff-name (str)
      "use the basename of this buffer to generate a name for a
    compent that is generated, thus related to this buffer"
      (concat (file-name-base (buffer-name (current-buffer))) str)
      )
#+END_SRC

#+RESULTS:
: buff-name


* DHCP Info

  Pulled from [[https://tools.ietf.org/html/rfc1531][RFC 1531]]

#+tblname: dhcp-f2
   | Field   | Octets | description                                                  | type   |
   |         |        | <60>                                                         |        |
   |---------+--------+--------------------------------------------------------------+--------|
   | op      |      1 | Message op code / message type. 1 = BOOTREQUEST, 2 = BOOTREPLY | int    |
   | htype   |      1 | Hardware address type, see ARP section in "Assigned Numbers" RFC; e.g., '1' = 10mb ethernet. | int    |
   | hlen    |      1 | Hardware address length (e.g. '6' for 10mb ethernet).        | int    |
   | hops    |      1 | Client sets to zero, optionally used by relay-agents when booting via a relay-agent. | int    |
   | xid     |      4 | Transaction ID, a random number chosen by the client, used by the client and server to associate messages and responses between a client and a server. | int    |
   | secs    |      2 | Filled in by client, seconds elapsed since client started trying to boot. | int    |
   | flags   |      2 | Flags (see figure 2).                                        | int    |
   | ciaddr  |      4 | Client IP address; filled in by client in DHCPREQUEST if verifying previously allocated configuration parameters. | int    |
   | yiaddr  |      4 | 'your' (client) IP address.                                  | int    |
   | siaddr  |      4 | IP address of next server to use in bootstrap; returned in DHCPOFFER, DHCPACK and DHCPNAK by server. | int    |
   | giaddr  |      4 | Relay agent IP address, used in booting via a relay-agent.   | int    |
   | chaddr  |     16 | Client hardware address.                                     | int    |
   | sname   |     64 | Optional server host name, null terminated string.           | string |
   | file    |    128 | Boot file name, null terminated string; "generic" name or null in DHCPDISCOVER, fully qualified directory-path name in DHCPOFFER. | string |
   | options |    312 | Optional parameters field.  See the options documents for a list of defined options. | rest   |

* Code Gen

** defclass from table
  
   Create an object with slots that match the table.

#+BEGIN_SRC lisp :var clazz=dhcp-f2 :results output verbatim :file (concat (file-name-base (buffer-name (current-buffer))) "-clos.lisp") :var name=(file-name-base (buffer-name (current-buffer))) :exports both
  (pprint
   `(defclass ,(->symbol name)
        ()
        ,(mapcar #'(lambda(row)
                     (trivia:match
                         row
                       ((list field octets description type)
                        (list (->symbol field)
                              :documentation description
                              :accessor (->symbol field)
                              :initarg (->keyword field)))))
                 (cddr clazz))
      )
   )
#+END_SRC

#+RESULTS:
[[file:dhcp-clos.lisp]]

** TODO add support for different types of strings
   - fixed
   - pascal
   - c

#+BEGIN_SRC lisp :var clazz=dhcp-f2 :results output verbatim :file (buff-name "-dehydrate.lisp") :var name=(buff-basename) :exports both
  (pprint
     `(progn
        (defmethod ,(->symbol (serapeum:concat "read-" name "-from-stream")) ((obj ,(->symbol name)) input-stream)
            ,@(mapcar #'(lambda(row)
                          (trivia:match 
                              row
                            ((list field octets descr da-type)
                             (let ((type (intern (string-upcase da-type) :keyword)))
                               (cond
                                 ((eq type :rest)
                                  `(setf (,(->symbol field) obj) (read-sequence  input-stream)))
                                 ;; Strings have a fixed length
                                 ;; Maybe we should handle fixed-length, pascal, and c with different
                                 ;; keywords?
                                 ((eq type :string)
                                  `(setf (,(->symbol field) obj)
                                         (loop :for i :upto ,octets :collect (read-char input-stream))))
                                 ((eq type :int)
                                  `(setf (,(->symbol field) obj) (octets->num (read-octets ,octets input-stream) :endian :big)))
                                 (t
                                  (error "Unexpected type ~a" row))
                                 )))))
                      (cddr  clazz))
            )
          )
        )
     )
#+END_SRC

#+RESULTS:
[[file:dhcp-dehydrate.lisp]]

#+BEGIN_SRC lisp :var clazz=dhcp-f2 :results output verbatim :file (buff-name "-hydrate.lisp") :var name=(buff-basename) :exports both
  (pprint
   `(progn
      (defmethod ,(->symbol (serapeum:concat name "-packet")) ((obj ,(->symbol name)))
        ,#+nil(flexi-streams:with-output-to-sequence (out :element-type '(unsigned-byte 8))
          (write-byte )
          )
        (with-open-file (out #P"/tmp/a" :direction :output :element-type '(unsigned-byte 8) :if-does-not-exist :create :if-exists :overwrite)
          ,@(mapcar #'(lambda(row)
                        (trivia:match 
                            row
                          ((list field octets descr da-type)
                           (let ((type (intern (string-upcase da-type) :keyword)))
                             (cond
                               ((eq type :rest)
                                `(write-sequence (,(->symbol field) obj) out))
                               ((eq type :string)
                                `(write-sequence (,(->symbol field) obj) out))
                               ((eq type :int)
                                `(write-seq (number->octets (,(->symbol field) obj) :n ,octets :endian :big) out))
                               (t
                                (error "Unexpected type ~a" row))
                               )))))
                    (cddr  clazz))
          )
        )
      )
   )
#+END_SRC

#+RESULTS:
[[file:dhcp-hydrate.lisp]]

** TODO dehydration to packet

  
#+BEGIN_SRC lisp

#+END_SRC

* hostapd 

* dhcp-discover
** give ip on staging network
   Low lease, very little bandwidth
** security challenge
   nmap device, get mac address, is there a profile for this device?

** Create a network, apply profiles for this device
*** IP aliasing on wlan0
    ip a add 192.168.1.101/255.255.255.0 dev eth0



* Staging Network
  dhcp-request => 1 minute lease
  nmap node => assign profile
  Create a new network
  dhcp-renew => give new ip/network


* Dev
  [[file:./dhcp-server.lisp]]
